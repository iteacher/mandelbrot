/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/main.ts":
/*!************************!*\
  !*** ./src/js/main.ts ***!
  \************************/
/***/ (() => {

eval("// Author: Julian Manders-Jones\n// Description:  Mandelbrot infinite zoom\n// License: MIT\n// Get canvas container\nvar canvasContainer = document.getElementById('canvas-container');\nif (!canvasContainer) {\n    throw new Error(\"Canvas container not found\");\n}\n// Create two canvases for double buffering\nvar displayCanvas = document.createElement('canvas');\nvar bufferCanvas = document.createElement('canvas');\nvar displayCtx = displayCanvas.getContext('2d', { alpha: false });\nvar bufferCtx = bufferCanvas.getContext('2d', { alpha: false });\nif (!displayCtx || !bufferCtx) {\n    throw new Error(\"Failed to get canvas contexts\");\n}\n// Style and append display canvas\ndisplayCanvas.style.position = 'absolute';\ndisplayCanvas.style.top = '0';\ndisplayCanvas.style.left = '0';\ndisplayCanvas.style.width = '100%';\ndisplayCanvas.style.height = '100%';\ndisplayCanvas.style.cursor = 'crosshair';\ncanvasContainer.appendChild(displayCanvas);\n// UI Elements\nvar zoomSpeedSlider = document.getElementById('zoom-speed-slider');\nvar zoomSpeedValue = document.getElementById('zoom-speed-value');\nvar statusText = document.getElementById('status-text');\nvar increaseSpeedBtn = document.getElementById('increase-speed');\nvar decreaseSpeedBtn = document.getElementById('decrease-speed');\n// Animation and rendering parameters\nvar targetFPS = 144;\nvar frameInterval = 1000 / targetFPS;\nvar lastFrameTime = 0;\nvar isRendering = false;\n// Mandelbrot view parameters\nvar offsetX = -0.7;\nvar offsetY = 0.0;\nvar maxIterationBase = 40;\n// Zoom parameters\nvar zoomFactor = 0.1;\nvar baseZoomSpeed = 0.003;\nvar zoomSpeedMultiplier = 1.0;\nvar maxZoomSpeedMultiplier = 5.0;\nvar minZoomSpeedMultiplier = -2.0;\n// Mouse tracking with dampening\nvar mouseX = window.innerWidth / 2;\nvar mouseY = window.innerHeight / 2;\nvar targetX = mouseX;\nvar targetY = mouseY;\nvar currentX = mouseX;\nvar currentY = mouseY;\nvar dampeningFactor = 0.1;\n// Center point animation\nvar targetOffsetX = offsetX;\nvar targetOffsetY = offsetY;\nvar isAnimatingCenter = false;\nvar centerAnimationSpeed = 0.1;\n// Control states\nvar isPaused = false;\nvar currentVelocityX = 0;\nvar currentVelocityY = 0;\nvar targetVelocityX = 0;\nvar targetVelocityY = 0;\n// Movement parameters\nvar movementSpeed = 0.0004;\nvar deadZone = 30;\nvar maxDeflection = 150;\nvar smoothing = 0.2;\nfunction updateZoomSpeedDisplay() {\n    if (zoomSpeedValue) {\n        var direction = zoomSpeedMultiplier >= 0 ? '→' : '←';\n        var magnitude = Math.abs(zoomSpeedMultiplier).toFixed(1);\n        zoomSpeedValue.textContent = \"\".concat(direction, \" \\u00D7\").concat(magnitude);\n    }\n}\nfunction updateStatusText(status) {\n    if (statusText) {\n        statusText.textContent = status;\n    }\n}\nfunction adjustZoomSpeed(delta) {\n    var currentValue = parseInt(zoomSpeedSlider.value);\n    var newValue = Math.max(-100, Math.min(100, currentValue + delta));\n    zoomSpeedSlider.value = newValue.toString();\n    zoomSpeedMultiplier = newValue / 33.33;\n    updateZoomSpeedDisplay();\n}\n// Initialize UI\nif (zoomSpeedSlider) {\n    zoomSpeedSlider.addEventListener('input', function () {\n        zoomSpeedMultiplier = parseInt(zoomSpeedSlider.value) / 33.33;\n        updateZoomSpeedDisplay();\n    });\n}\nif (increaseSpeedBtn) {\n    increaseSpeedBtn.addEventListener('click', function () { return adjustZoomSpeed(10); });\n}\nif (decreaseSpeedBtn) {\n    decreaseSpeedBtn.addEventListener('click', function () { return adjustZoomSpeed(-10); });\n}\n// Handle keyboard controls\ndocument.addEventListener('keydown', function (event) {\n    if (event.key === '+' || event.key === '=') {\n        adjustZoomSpeed(10);\n    }\n    else if (event.key === '-' || event.key === '_') {\n        adjustZoomSpeed(-10);\n    }\n    else if (event.code === 'Space') {\n        event.preventDefault();\n        isPaused = !isPaused;\n        updateStatusText(isPaused ? 'PAUSED' : 'FLYING');\n    }\n});\n// Function to update both canvases\nfunction updateCanvases() {\n    // Get actual pixel dimensions of the container\n    var rect = canvasContainer.getBoundingClientRect();\n    var width = Math.floor(rect.width);\n    var height = Math.floor(rect.height);\n    // Set canvas dimensions to match container size\n    displayCanvas.width = width;\n    displayCanvas.height = height;\n    bufferCanvas.width = width;\n    bufferCanvas.height = height;\n    // Clear both canvases with black background\n    displayCtx.fillStyle = 'black';\n    displayCtx.fillRect(0, 0, width, height);\n    bufferCtx.fillStyle = 'black';\n    bufferCtx.fillRect(0, 0, width, height);\n}\n// Initial setup\nupdateCanvases();\n// Handle window resizes\nwindow.addEventListener('resize', function () {\n    updateCanvases();\n    drawMandelbrot();\n});\n// Convert screen coordinates to complex plane coordinates\nfunction screenToComplex(screenX, screenY) {\n    var width = displayCanvas.width;\n    var height = displayCanvas.height;\n    var aspectRatio = width / height;\n    var scale = 4 / Math.pow(2, zoomFactor);\n    var normalizedX = screenX / width - 0.5;\n    var normalizedY = screenY / height - 0.5;\n    var scaledX = normalizedX * scale * aspectRatio;\n    var scaledY = normalizedY * scale;\n    return [\n        scaledX + offsetX,\n        scaledY + offsetY\n    ];\n}\nfunction calculateMovementVector(mouseX, mouseY) {\n    var centerX = displayCanvas.width / 2;\n    var centerY = displayCanvas.height / 2;\n    var deltaX = mouseX - centerX;\n    var deltaY = mouseY - centerY;\n    var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    if (distance < deadZone) {\n        return [0, 0];\n    }\n    var strength = Math.min(Math.pow((distance - deadZone) / (maxDeflection - deadZone), 2), 1);\n    var normalizedX = (deltaX / distance) * strength;\n    var normalizedY = (deltaY / distance) * strength;\n    return [normalizedX, normalizedY];\n}\nfunction updateMovement() {\n    if (isPaused) {\n        targetVelocityX = 0;\n        targetVelocityY = 0;\n    }\n    else if (!isAnimatingCenter) {\n        var _a = calculateMovementVector(mouseX, mouseY), moveX = _a[0], moveY = _a[1];\n        targetVelocityX = moveX * movementSpeed;\n        targetVelocityY = moveY * movementSpeed;\n    }\n    currentVelocityX += (targetVelocityX - currentVelocityX) * smoothing;\n    currentVelocityY += (targetVelocityY - currentVelocityY) * smoothing;\n    if (!isAnimatingCenter) {\n        offsetX += currentVelocityX;\n        offsetY += currentVelocityY;\n    }\n}\nfunction updateCenterAnimation() {\n    if (!isAnimatingCenter)\n        return;\n    var dx = targetOffsetX - offsetX;\n    var dy = targetOffsetY - offsetY;\n    var distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance < 0.0001) {\n        isAnimatingCenter = false;\n        offsetX = targetOffsetX;\n        offsetY = targetOffsetY;\n        updateStatusText('FLYING');\n        return;\n    }\n    offsetX += dx * centerAnimationSpeed;\n    offsetY += dy * centerAnimationSpeed;\n}\nfunction updateZoom() {\n    if (isPaused)\n        return;\n    var effectiveZoomSpeed = baseZoomSpeed * zoomSpeedMultiplier;\n    zoomFactor *= (1 + effectiveZoomSpeed);\n    if (zoomFactor > 1e10 || zoomFactor < 0.1) {\n        zoomFactor = 0.1;\n    }\n}\nfunction mandelbrot(x, y, maxIterations) {\n    var real = x;\n    var imaginary = y;\n    var iterations = 0;\n    var zReal = 0;\n    var zImaginary = 0;\n    while (iterations < maxIterations) {\n        var zRealSquared = zReal * zReal;\n        var zImaginarySquared = zImaginary * zImaginary;\n        if (zRealSquared + zImaginarySquared > 4) {\n            break;\n        }\n        zImaginary = 2 * zReal * zImaginary + imaginary;\n        zReal = zRealSquared - zImaginarySquared + real;\n        iterations++;\n    }\n    return iterations;\n}\nfunction getColor(iterations, maxIterations) {\n    if (iterations === maxIterations)\n        return [0, 0, 0];\n    var hue = (iterations / maxIterations) * 360;\n    var saturation = 100;\n    var lightness = 50;\n    var c = (1 - Math.abs(2 * lightness / 100 - 1)) * saturation / 100;\n    var x = c * (1 - Math.abs((hue / 60) % 2 - 1));\n    var m = lightness / 100 - c / 2;\n    var r = 0, g = 0, b = 0;\n    if (hue < 60) {\n        r = c;\n        g = x;\n    }\n    else if (hue < 120) {\n        r = x;\n        g = c;\n    }\n    else if (hue < 180) {\n        g = c;\n        b = x;\n    }\n    else if (hue < 240) {\n        g = x;\n        b = c;\n    }\n    else if (hue < 300) {\n        r = x;\n        b = c;\n    }\n    else {\n        r = c;\n        b = x;\n    }\n    return [\n        Math.floor((r + m) * 255),\n        Math.floor((g + m) * 255),\n        Math.floor((b + m) * 255)\n    ];\n}\nfunction drawMandelbrot() {\n    if (!bufferCtx || !displayCtx)\n        return;\n    var maxIterations = Math.floor(Math.log2(zoomFactor) * 5) + maxIterationBase;\n    var width = bufferCanvas.width;\n    var height = bufferCanvas.height;\n    var aspectRatio = width / height;\n    var scale = 4 / Math.pow(2, zoomFactor);\n    var xMin = offsetX - (scale * aspectRatio) / 2;\n    var xMax = offsetX + (scale * aspectRatio) / 2;\n    var yMin = offsetY - scale / 2;\n    var yMax = offsetY + scale / 2;\n    var imageData = bufferCtx.createImageData(width, height);\n    for (var y = 0; y < height; y++) {\n        var cy = yMin + (y * (yMax - yMin)) / height;\n        for (var x = 0; x < width; x++) {\n            var cx = xMin + (x * (xMax - xMin)) / width;\n            var q = (cx - 0.25) * (cx - 0.25) + cy * cy;\n            if (q * (q + (cx - 0.25)) <= 0.25 * cy * cy ||\n                (cx + 1) * (cx + 1) + cy * cy <= 0.0625) {\n                var pixelIndex_1 = (x + y * width) * 4;\n                imageData.data[pixelIndex_1] = 0;\n                imageData.data[pixelIndex_1 + 1] = 0;\n                imageData.data[pixelIndex_1 + 2] = 0;\n                imageData.data[pixelIndex_1 + 3] = 255;\n                continue;\n            }\n            var iterations = mandelbrot(cx, cy, maxIterations);\n            var _a = getColor(iterations, maxIterations), r = _a[0], g = _a[1], b = _a[2];\n            var pixelIndex = (x + y * width) * 4;\n            imageData.data[pixelIndex] = r;\n            imageData.data[pixelIndex + 1] = g;\n            imageData.data[pixelIndex + 2] = b;\n            imageData.data[pixelIndex + 3] = 255;\n        }\n    }\n    bufferCtx.putImageData(imageData, 0, 0);\n    displayCtx.drawImage(bufferCanvas, 0, 0);\n}\n// Track mouse movement\ndisplayCanvas.addEventListener('mousemove', function (event) {\n    var rect = displayCanvas.getBoundingClientRect();\n    mouseX = (event.clientX - rect.left) * (displayCanvas.width / rect.width);\n    mouseY = (event.clientY - rect.top) * (displayCanvas.height / rect.height);\n});\n// Handle clicks to set new center point\ndisplayCanvas.addEventListener('click', function (event) {\n    var rect = displayCanvas.getBoundingClientRect();\n    var clickX = (event.clientX - rect.left) * (displayCanvas.width / rect.width);\n    var clickY = (event.clientY - rect.top) * (displayCanvas.height / rect.height);\n    var _a = screenToComplex(clickX, clickY), newX = _a[0], newY = _a[1];\n    targetOffsetX = newX;\n    targetOffsetY = newY;\n    isAnimatingCenter = true;\n    updateStatusText('CENTERING');\n    currentVelocityX = 0;\n    currentVelocityY = 0;\n    targetVelocityX = 0;\n    targetVelocityY = 0;\n});\n// Handle right click to pause/unpause\ndisplayCanvas.addEventListener('contextmenu', function (event) {\n    event.preventDefault();\n    isPaused = !isPaused;\n    updateStatusText(isPaused ? 'PAUSED' : 'FLYING');\n});\n// Start animation loop\nrequestAnimationFrame(function render(currentTime) {\n    if (!lastFrameTime)\n        lastFrameTime = currentTime;\n    updateMovement();\n    updateCenterAnimation();\n    updateZoom();\n    drawMandelbrot();\n    lastFrameTime = currentTime;\n    requestAnimationFrame(render);\n});\n\n\n//# sourceURL=webpack://mandelbrot/./src/js/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/main.ts"]();
/******/ 	
/******/ })()
;